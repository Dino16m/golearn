// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//+build !wireinject

package dependencies

import (
	"github.com/appleboy/gin-jwt/v2"
	"github.com/dino16m/GinSessionMW/middleware"
	"github.com/dino16m/golearn/adapters"
	"github.com/dino16m/golearn/config"
	"github.com/dino16m/golearn/controllers"
	"github.com/dino16m/golearn/events"
	"github.com/dino16m/golearn/forms"
	"github.com/dino16m/golearn/jobs"
	"github.com/dino16m/golearn/lib/event"
	"github.com/dino16m/golearn/lib/mail"
	"github.com/dino16m/golearn/mails"
	"github.com/dino16m/golearn/middlewares"
	"github.com/dino16m/golearn/services"
	"github.com/dino16m/golearn/types"
	"github.com/gin-contrib/cors"
	"github.com/gin-contrib/sessions"
	"github.com/gin-contrib/sessions/redis"
	"github.com/gin-gonic/gin"
	"github.com/gobuffalo/gocraft-work-adapter"
	redis2 "github.com/gomodule/redigo/redis"
	"github.com/google/wire"
	"github.com/natefinch/lumberjack"
	"github.com/sirupsen/logrus"
)

// Injectors from app.go:

// initializeSession get a session
func initializeSession() (gin.HandlerFunc, error) {
	superConfig := ProvideSuperConfig()
	string2 := superConfig.AppName
	store, err := provideRedisStore(superConfig)
	if err != nil {
		return nil, err
	}
	handlerFunc := sessions.Sessions(string2, store)
	return handlerFunc, nil
}

func initializeJwMw(authService services.AuthService) (*jwt.GinJWTMiddleware, error) {
	superConfig := ProvideSuperConfig()
	jwtOptions := superConfig.JwtOptions
	authenticatorFunc := provideAuthService(authService)
	ginJWTMiddleware, err := middlewares.GetJwtMiddleware(jwtOptions, authenticatorFunc)
	if err != nil {
		return nil, err
	}
	return ginJWTMiddleware, nil
}

func initializeSessionAuthMW(userRepo types.UserRepository) *middleware.SessionMiddleware {
	superConfig := ProvideSuperConfig()
	options := superConfig.SessionOptions
	v := provideAuthUserRepo(userRepo)
	v2 := provideSessionFunc()
	sessionMiddleware := middlewares.GetSessionMw(options, v, v2)
	return sessionMiddleware
}

func initializeJwtAuthAdapter(repo types.UserRepository) adapters.JwtAuthUserManager {
	superConfig := ProvideSuperConfig()
	string2 := provideIdentityKey(superConfig)
	v := provideAuthUserRepo(repo)
	jwtAuthUserManager := adapters.NewJwtAuthUserManager(string2, v)
	return jwtAuthUserManager
}

// initializeAll Get all the objects needed to start app
func initializeAll(services2 ServicesContainer, repos RepositoriesContainer) (App, error) {
	handlerFunc, err := initializeSession()
	if err != nil {
		return App{}, err
	}
	authService := services2.AuthService
	ginJWTMiddleware, err := initializeJwMw(authService)
	if err != nil {
		return App{}, err
	}
	userRepository := repos.UserRepo
	sessionMiddleware := initializeSessionAuthMW(userRepository)
	jwtAuthUserManager := initializeJwtAuthAdapter(userRepository)
	sessionAuthUserManager := provideSessionAuthAdapter(sessionMiddleware)
	authEventDispatcher := provideEventDispatcher()
	superConfig := ProvideSuperConfig()
	pool := provideRedisPool(superConfig)
	adapter := provideWorker(pool, superConfig)
	csrfMiddleware := provideCSRFMiddleware(superConfig)
	apicorsMiddleware := provideAPICORSMiddleware(superConfig)
	webCORSMiddleware := provideWebCORSMiddleware(superConfig)
	logger := provideLogger()
	app := App{
		SessionMw:             handlerFunc,
		JwtAuthMW:             ginJWTMiddleware,
		SessionAuthMiddleware: sessionMiddleware,
		ApiUserManager:        jwtAuthUserManager,
		SessionUserManager:    sessionAuthUserManager,
		EventDispatcher:       authEventDispatcher,
		Worker:                adapter,
		CSRFMiddleware:        csrfMiddleware,
		APICORS:               apicorsMiddleware,
		WebCORS:               webCORSMiddleware,
		Logger:                logger,
	}
	return app, nil
}

// Injectors from controllers.go:

// InitRepos create the repository container
func InitControllers(repos RepositoriesContainer, services2 ServicesContainer, app App) ControllersContainer {
	authController := provideAuthController(app, services2, repos)
	emailVerifService := services2.EmailVerifService
	userRepository := repos.UserRepo
	emailVerifController := controllers.NewEmailVerifController(emailVerifService, userRepository)
	passwordResetService := services2.PasswordResetService
	authService := services2.AuthService
	superConfig := ProvideSuperConfig()
	string2 := superConfig.AppName
	passwordResetController := controllers.NewPasswordResetController(passwordResetService, userRepository, authService, string2)
	controllersContainer := ControllersContainer{
		AuthController:          authController,
		EmailVerifController:    emailVerifController,
		PasswordResetController: passwordResetController,
	}
	return controllersContainer
}

// Injectors from event_handlers.go:

func InitEventHandlers(s ServicesContainer, m MailsContainer) EventHandlersContainer {
	authMail := m.AuthMail
	emailVerifService := s.EmailVerifService
	userCreatedHandler := events.NewUserCreatedHandler(authMail, emailVerifService)
	eventHandlersContainer := EventHandlersContainer{
		UserCreatedHandler: userCreatedHandler,
	}
	return eventHandlersContainer
}

// Injectors from job_handlers.go:

// InitJobs Create the jobs container
func InitJobs(mails MailsContainer) JobHandlersContainer {
	authMail := mails.AuthMail
	userCreatedHandler := jobs.NewUserCreatedHandler(authMail)
	jobHandlersContainer := JobHandlersContainer{
		UserCreatedHandler: userCreatedHandler,
	}
	return jobHandlersContainer
}

// Injectors from mails.go:

// InitMails creates all the mails for the container
func InitMails() (MailsContainer, error) {
	authMail, err := provideAuthMail()
	if err != nil {
		return MailsContainer{}, err
	}
	mailsContainer := MailsContainer{
		AuthMail: authMail,
	}
	return mailsContainer, nil
}

// Injectors from repositories.go:

// InitRepos create the repository container
func InitRepos(repo types.UserRepository) RepositoriesContainer {
	repositoriesContainer := RepositoriesContainer{
		UserRepo: repo,
	}
	return repositoriesContainer
}

// Injectors from services.go:

// InitServices wires up the ServicesContainer
func InitServices(repos RepositoriesContainer, mails MailsContainer) (ServicesContainer, error) {
	userRepository := repos.UserRepo
	authService := services.NewAuthService(userRepository)
	superConfig := ProvideSuperConfig()
	emailVerifService, err := provideEmailVerifService(mails, superConfig)
	if err != nil {
		return ServicesContainer{}, err
	}
	passwordResetService, err := providePasswordResetService(mails, superConfig)
	if err != nil {
		return ServicesContainer{}, err
	}
	servicesContainer := ServicesContainer{
		AuthService:          authService,
		EmailVerifService:    emailVerifService,
		PasswordResetService: passwordResetService,
	}
	return servicesContainer, nil
}

// app.go:

func provideRedisStore(cfg config.SuperConfig) (sessions.Store, error) {
	options := cfg.RedisStoreOptions

	return redis.NewStore(
		options.Size,
		options.Network,
		options.Address,
		options.Password,
		[]byte(options.KeyPairs),
	)
}

func provideAuthService(service services.AuthService) middlewares.AuthenticatorFunc {
	return service.Authenticate
}

func provideSessionFunc() func(c *gin.Context) sessions.Session {
	return sessions.Default
}

func provideAuthUserRepo(repo types.UserRepository) func(key interface{}) types.AuthUser {
	return repo.GetUserByAuthId
}

func provideSessionAuthAdapter(
	mw *middleware.SessionMiddleware) adapters.SessionAuthUserManager {
	return adapters.NewSessionAuthUserManager(mw)
}

func provideIdentityKey(cfg config.SuperConfig) string {
	return cfg.JwtOptions.IdentityKey
}

func provideEventDispatcher() *event.AuthEventDispatcher {
	return event.NewAuthEventDispatcher()
}

func ProvideSuperConfig() config.SuperConfig {
	if config.IsSet() == false {
		panic("Config must be set up")
	}
	return config.Config
}

func provideRedisPool(cfg config.SuperConfig) *redis2.Pool {
	options := cfg.RedisStoreOptions
	dialPasswordOption := redis2.DialPassword(options.Password)
	return &redis2.Pool{
		MaxActive: 5,
		MaxIdle:   5,
		Wait:      true,
		Dial: func() (redis2.Conn, error) {
			return redis2.Dial(
				options.Network, options.Address, dialPasswordOption)
		},
	}
}

func provideWorker(pool *redis2.Pool, cfg config.SuperConfig) *gwa.Adapter {
	return gwa.New(gwa.Options{
		Pool:           pool,
		Name:           cfg.AppName,
		MaxConcurrency: 25,
	})
}

func provideCSRFMiddleware(cfg config.SuperConfig) middlewares.CSRFMiddleware {
	return middlewares.NewCSRFMiddleware(cfg.SecretKey,
		cfg.Env, cfg.SessionOptions)
}

func provideWebCORSMiddleware(cfg config.SuperConfig) WebCORSMiddleware {
	defaultCfg := cors.DefaultConfig()
	defaultCfg.AllowHeaders = append(defaultCfg.AllowHeaders, "X-CSRF-TOKEN")
	validCfg := updateCORSCfg(cfg.WebCORSConfig, defaultCfg)
	return WebCORSMiddleware(cors.New(validCfg))
}

func provideAPICORSMiddleware(cfg config.SuperConfig) APICORSMiddleware {
	defaultCfg := cors.DefaultConfig()
	defaultCfg.AllowHeaders = append(defaultCfg.AllowHeaders, "X-CSRF-TOKEN")
	validCfg := updateCORSCfg(cfg.APICORSConfig, defaultCfg)
	return APICORSMiddleware(cors.New(validCfg))
}

func updateCORSCfg(update config.CORSConfig, original cors.Config) cors.Config {
	original.AllowAllOrigins = update.AllowAllOrigins
	original.AllowCredentials = update.AllowCredentials
	original.AllowWildcard = update.AllowWildcard
	if len(update.AllowHeaders) > 0 {
		original.AllowHeaders = append(original.AllowHeaders, update.AllowHeaders...)
	}
	if len(update.AllowMethods) > 0 {
		original.AllowMethods = update.AllowMethods
	}
	if len(update.AllowOrigins) > 0 {
		original.AllowOrigins = update.AllowOrigins
	}
	if len(update.ExposeHeaders) > 0 {
		original.ExposeHeaders = update.ExposeHeaders
	}
	return original
}

func provideLogger() *logrus.Logger {
	log := logrus.New()
	cfg := ProvideSuperConfig().LoggerConfig
	if cfg.Filename != "" {
		log.Out = &lumberjack.Logger{
			Filename:   cfg.Filename,
			MaxSize:    cfg.MaxSize,
			MaxBackups: cfg.MaxBackups,
			MaxAge:     cfg.MaxAge,
			Compress:   cfg.Compress,
		}
	}
	return log
}

func InitApp(services2 ServicesContainer,
	repos RepositoriesContainer) (App, error) {
	return initializeAll(services2, repos)
}

type APICORSMiddleware gin.HandlerFunc

type WebCORSMiddleware gin.HandlerFunc

// App the fully constructed app, containing required values
type App struct {
	SessionMw             gin.HandlerFunc
	JwtAuthMW             *jwt.GinJWTMiddleware
	SessionAuthMiddleware *middleware.SessionMiddleware
	ApiUserManager        adapters.JwtAuthUserManager
	SessionUserManager    adapters.SessionAuthUserManager
	EventDispatcher       event.Dispatcher
	Worker                *gwa.Adapter
	CSRFMiddleware        middlewares.CSRFMiddleware
	APICORS               APICORSMiddleware
	WebCORS               WebCORSMiddleware
	Logger                types.Logger
}

// controllers.go:

func provideAuthController(
	app App, services2 ServicesContainer,
	repos RepositoriesContainer,
) controllers.AuthController {
	return controllers.NewAuthController(
		app.SessionAuthMiddleware, services2.
			AuthService, repos.UserRepo, forms.SignUpForm{}, app.EventDispatcher,
	)
}

var emailVerifControllerSet = wire.NewSet(wire.Bind(
	new(controllers.EmailVerificationService),
	new(services.EmailVerifService)), wire.FieldsOf(new(ServicesContainer), "EmailVerifService"), controllers.NewEmailVerifController,
)

var passwordResetControllerSet = wire.NewSet(wire.Bind(
	new(controllers.PasswordResetService),
	new(services.PasswordResetService)), wire.FieldsOf(new(ServicesContainer), "PasswordResetService"), wire.FieldsOf(new(ServicesContainer), "AuthService"), wire.Bind(new(types.Authenticator), new(services.AuthService)), controllers.NewPasswordResetController, wire.FieldsOf(new(config.SuperConfig), "AppName"),
)

var sharedDependencies = wire.NewSet(wire.FieldsOf(new(RepositoriesContainer), "UserRepo"), ProvideSuperConfig)

// Container is a super struct which contains all the controllers
// available in this app, it will enable service locators to function.
type ControllersContainer struct {
	AuthController          controllers.AuthController
	EmailVerifController    controllers.EmailVerifController
	PasswordResetController controllers.PasswordResetController
}

// event_handlers.go:

type EventHandlersContainer struct {
	UserCreatedHandler events.UserCreatedHandler
}

var welcomeMailerSet = wire.NewSet(wire.FieldsOf(new(MailsContainer), "AuthMail"), wire.Bind(new(events.WelcomeMailer), new(mails.AuthMail)))

var verificationServiceSet = wire.NewSet(wire.FieldsOf(new(ServicesContainer), "EmailVerifService"), wire.Bind(new(events.VerificationService), new(services.EmailVerifService)))

var userCreatedEventHandlerSet = wire.NewSet(
	verificationServiceSet,
	welcomeMailerSet, events.NewUserCreatedHandler,
)

// job_handlers.go:

var userCreatedJobHandlerSet = wire.NewSet(wire.Bind(new(jobs.UserCreatedMail), new(mails.AuthMail)), wire.FieldsOf(new(MailsContainer), "AuthMail"), jobs.NewUserCreatedHandler)

// JobHandlersContainer is a super struct which contains all the repositories
// available in a repository package, it will enable service locators to function.
type JobHandlersContainer struct {
	UserCreatedHandler jobs.UserCreatedHandler
}

// mails.go:

// MailsContainer ...
type MailsContainer struct {
	AuthMail mails.AuthMail
}

func provideMailer() *mail.Mailer {
	mailOpts := ProvideSuperConfig().MailOptions
	return mail.NewMailer(
		mailOpts.SenderName, mailOpts.FromEmail, mailOpts.Host,
		mailOpts.Port, mailOpts.Username, mailOpts.Password,
	)
}

func provideDummyMailer() *mail.ConsoleMailer {
	return mail.NewConsoleMailer()
}

func provideIMailer() mail.IMailer {
	env := ProvideSuperConfig().Env
	var mailer mail.IMailer
	if env == "production" {
		mailer = provideMailer()
	} else {
		mailer = provideDummyMailer()
	}
	return mailer
}

func provideAuthMail() (mails.AuthMail, error) {
	mailer := provideIMailer()
	appName := ProvideSuperConfig().AppName
	t := ProvideSuperConfig().AuthMailTemplates
	return mails.NewAuthMail(appName,
		mailer, t.EmailVerifTxt,
		t.EmailVerifHTML,
		t.PasswordResetCodeTxt,
		t.PasswordResetCodeHTML, t.PasswordResetLinkTxt,
		t.PasswordResetLinkHTML)

}

// repositories.go:

// RepositoriesContainer is a super struct which contains all the repositories
// available in a repository package, it will enable service locators to function.
type RepositoriesContainer struct {
	UserRepo types.UserRepository
}

// services.go:

// ServicesContainer is a super struct which contains all the services
// available in this app, it will enable service locators to function.
type ServicesContainer struct {
	AuthService          services.AuthService
	EmailVerifService    services.EmailVerifService
	PasswordResetService services.PasswordResetService
}

var authServiceSet = wire.NewSet(wire.FieldsOf(new(RepositoriesContainer), "UserRepo"), services.NewAuthService)

func providePasswordResetService(mails2 MailsContainer,
	cfg config.SuperConfig) (services.PasswordResetService, error) {
	return services.NewPasswordResetService(
		"verify-password-reset-link",
		cfg.SecretKey, mails2.AuthMail)
}

func provideEmailVerifService(mails2 MailsContainer,
	cfg config.SuperConfig) (services.EmailVerifService, error) {
	return services.NewEmailVerifService("verify-email",
		cfg.SecretKey, mails2.AuthMail)
}
